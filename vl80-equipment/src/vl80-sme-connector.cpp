#include    "vl80-sme-connector.h"

#include    "vl80-sme-signals.h"

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
VL80SME::VL80SME(QObject *parent) : Device(parent)
  , is_ref_state_command(false)
{
    name = QString("VL80SME");

    input_signals.resize(NUM_VL80_SME_SIGNALS);
    output_signals.resize(NUM_VL80_SME_SIGNALS);

    std::fill(input_signals.begin(), input_signals.end(), 0.0);
    std::fill(output_signals.begin(), output_signals.end(), 0.0);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
VL80SME::~VL80SME()
{

}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::setKeyCode(int key_code)
{
    keyCode = key_code;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::connect()
{
    output_signals[SME_OUTPUT_REF_STATE] = 1.0;
    is_ref_state_command = true;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::disconnect()
{
    output_signals[SME_OUTPUT_REF_STATE] = -1.0;
    is_ref_state_command = true;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
bool VL80SME::isConnected() const
{
    return is_linked && (input_signals[SME_INPUT_IS_CONNECTED] == 1.0);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::setSignal(size_t idx, double value)
{
    if (idx < output_signals.size())
        output_signals[idx] = value;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
double VL80SME::getSignal(size_t idx) const
{
    if ((is_linked) && (idx < input_signals.size()))
        return input_signals[idx];
    else
        return 0.0;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::step(double t, double dt)
{
    // Проверяем управление
    stepKeysControl(t, dt);

    // Проверяем, вызывались ли методы управления рукавами на данном шаге
    if (is_ref_state_command)
    {
        // Сбрасываем флаг, чтобы обнулить управляющий сигнал на следующем шаге
        is_ref_state_command = false;
    }
    else
    {
        // Если не вызывались, обнуляем управляющий сигнал
        output_signals[SME_OUTPUT_REF_STATE] = 0.0f;
    }
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::ode_system(const state_vector_t &Y,
                           state_vector_t &dYdt,
                           double t)
{
    Q_UNUSED(Y)
    Q_UNUSED(dYdt)
    Q_UNUSED(t)
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void VL80SME::stepKeysControl(double t, double dt)
{
    (void) t;
    (void) dt;

    // Проверяем управляющий сигнал
    if (getKeyState(keyCode))
    {
        if (isShift() && (!isControl()))
        {
            // Пытаемся соединить секции по СМЕ
            connect();
        }
        else
        {
            if (isControl())
                // Разъединяем СМЕ
                disconnect();
        }
    }
}
